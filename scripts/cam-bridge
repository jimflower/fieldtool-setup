#!/usr/bin/env bash
[ -f /opt/fieldtool/config.env ] && . /opt/fieldtool/config.env || true
set -euo pipefail

act="${1:-status}"
in_if="${2:-wlan0}"
out_if="${3:-eth0}"
net="${4:-}"   # optional, e.g. 192.168.88.0/24

net24_of(){ awk -F'[./]' '{printf "%s.%s.%s.0/24",$1,$2,$3}'; }

list_labelled() {
  ip -o -4 addr show dev "$out_if" 2>/dev/null | sed 's/\\$//' | \
  awk -v ifc="$out_if" '
    $0 ~ /scope global/ {
      cidr=$4; label="";
      for (i=1;i<=NF;i++) if ($i ~ "^"ifc":") {label=$i; break}
      if (label!="") print cidr, label
    }'
}

infer_or_pick_net() {
  # use provided
  if [[ -n "${net:-}" ]]; then echo "$net"; return; fi

  mapfile -t LINES < <(list_labelled)
  ((${#LINES[@]})) || { echo ""; return; }

  # group by /24 & note if :cam exists
  declare -A GROUP MEMBERS HAS_CAM
  for line in "${LINES[@]}"; do
    cidr="${line%% *}"; label="${line##* }"
    n="$(printf "%s\n" "$cidr" | net24_of)"
    GROUP["$n"]=1
    MEMBERS["$n"]+="${MEMBERS[$n]:+ }${cidr}(${label})"
    [[ "$label" == "$out_if:cam" ]] && HAS_CAM["$n"]=1 || true
  done
  nets=( "${!GROUP[@]}" )

  # one choice → auto
  if ((${#nets[@]}==1)); then echo "${nets[0]}"; return; fi
  # prefer a net that has :cam label
  for n in "${nets[@]}"; do [[ -n "${HAS_CAM[$n]:-}" ]] && { echo "$n"; return; }; done

  # prompt (stderr) & return only the chosen net on stdout
  {
    echo "Select subnet to bridge (IN=${in_if} → OUT=${out_if}):"
    i=1; declare -A IDX
    for n in "${nets[@]}"; do
      echo "  $i) $n   [${MEMBERS[$n]}]"
      IDX[$i]="$n"; ((i++))
    done
  } 1>&2
  while true; do
    read -rp "Choice (1-$((i-1)) or q to cancel): " sel
    [[ "${sel:-}" =~ ^[Qq]$ ]] && { echo ""; return; }
    [[ "${sel:-}" =~ ^[0-9]+$ ]] && (( sel>=1 && sel<i )) && { echo "${IDX[$sel]}"; return; }
    echo "Invalid selection." 1>&2
  done
}

start_bridge() {
  local n; n="$(infer_or_pick_net)"
  [[ -z "${n:-}" ]] && { echo "[ERR] Could not determine subnet; add an alias (menu 5) or pass NET." >&2; exit 2; }

  sudo sysctl -w net.ipv4.ip_forward=1 >/dev/null
  sudo nft delete table ip cambridge 2>/dev/null || true
  sudo nft delete table ip camnat    2>/dev/null || true

  sudo nft add table ip cambridge
  sudo nft add chain ip cambridge forward '{ type filter hook forward priority filter; policy accept; }'
  sudo nft add rule  ip cambridge forward iifname "$in_if"  oifname "$out_if" ip daddr $n accept
  sudo nft add rule  ip cambridge forward iifname "$out_if" oifname "$in_if"  ct state established,related accept
  sudo nft add rule  ip cambridge forward iifname "$in_if"  oifname "$out_if" ip protocol icmp ip daddr $n accept

  sudo nft add table ip camnat
  sudo nft add chain ip camnat post '{ type nat hook postrouting priority srcnat; policy accept; }'
  sudo nft add rule  ip camnat post oifname "$out_if" ip daddr $n masquerade

  echo "[OK] Bridge active. IN=${in_if} OUT=${out_if} NET=${n}"
  status_bridge
}

stop_bridge(){ sudo nft delete table ip cambridge 2>/dev/null || true; sudo nft delete table ip camnat 2>/dev/null || true; echo "[OK] Bridge stopped."; }
status_bridge(){
  echo "=== cam-bridge status ==="
  echo "IN_IF=${in_if}  OUT_IF=${out_if}  NET=${net:-auto}"
  echo -n "ip_forward: "; sysctl -n net.ipv4.ip_forward
  echo "-- nft filter.forward --"; sudo nft list table ip cambridge 2>/dev/null || echo "(none)"
  echo "-- nft nat.post --";      sudo nft list table ip camnat    2>/dev/null || echo "(none)"
}

case "${act}" in
  start) start_bridge ;; stop) stop_bridge ;; status) status_bridge ;;
  *) echo "Usage: cam-bridge {start|stop|status} [IN_IF] [OUT_IF] [NET]"; exit 2 ;;
esac
